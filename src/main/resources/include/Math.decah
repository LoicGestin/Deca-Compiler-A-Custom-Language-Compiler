class Float {

    float _modulo(float f1, float f2){
        int k = (int)(f1/f2);
        return f1-k*f2;
    }

    int _sign(float f){
        if (f<0){
            return -1;
        }
        return 1;
    }

    float _abs(float f){
        if (f>=0){
            return f;
        }
        else{
            return -f;
        }
    }

    float _pow(float f, int exp) {
        if (exp == 0) {
            return 1;
        }
        if (exp>0) {
            return f * this._pow(f, exp - 1);
        }
        return this._pow(f,exp+1)/f;
    }

    float _fact(int n){
        if (n==0){
            return 1;
        }
        return this._fact(n-1);
    }

    void _forceOverflow() asm ("BOV overflow_error");
}

class Math {

    float PI = 3.1415927;
    Float m = new Float();

    float _sinHorner(float f2, int n, float invFact) {

        invFact = invFact / (2 * n * (2 * n + 1));

        if (n == 255) {
            return f2 * invFact;
        }

        return invFact - f2 * this._sinHorner(f2, n + 1, invFact);
    }

    float sin(float f) {
        float f2;
        float inter_res;
        f = m._modulo(f, 2*this.PI);
        f2 = f*f;


        if (f == 0) {
            return 0;
        }

        inter_res = 1 - f2 * this._sinHorner(f2, 1, 1);

        return f * inter_res;
    }

    float cosNaif(float f){
        float somme = 0.0;
        int n =0;
        while (n != 255) {
            somme = somme + m._pow(-1,n)*m._pow(f, 2*n)/m._fact(2*n);
            n=n+1;
        }
        return somme;
    }

    float cosHorner(float f2, int n, float invFact) {

        invFact = invFact/(2*n*(2*n-1));

        if (n == 255) {
            return f2 * invFact;
        }

        return invFact - f2 * this.cosHorner(f2, n + 1, invFact);
    }

    float cos(float f) {
        float f2;
        f = m._modulo(f, 2*this.PI);
        f2 = f*f;

        return 1-f2*this.cosHorner(f2, 1, 1);
    }

    float asinHorner(float f2, int n, float recN) {
        recN = recN*(1-1/(2*n));

        if (n == 255) {
            return recN * f2/(2*n+1);
        }

        return recN/(2*n+1) + f2 * this.asinHorner(f2, n + 1,recN);
    }

    float asin(float f) {

        float f2 = f*f;
        float inter_res;

        if (m._abs(f) > 1) {
            println("Arithmetic Overflow"); //Force OverFlow
            return 0;
        } else if (f == 0) {
            return 0;
        }else{
            inter_res = 1+f2*this.asinHorner(f2, 1, 1);
            return f*inter_res;
        }
    }

    float atanHorner(float f2, int n){
        if (n==255){
            return f2/(2*n+1);
        }

        return 1/(2*n+1) - f2*this.atanHorner(f2,n+1);
    }

    float atan(float f) {

        float f2 = f*f;

        if (f == 0) {
            return 0;
        } else if (m._abs(f) > 1) {
            return (1/f)*this.atanHorner(1/f2,0)+m._sign(f)*this.PI/2;
        }
        return f*this.atanHorner(f2,0);
    }

    float ulp(float f){
        Float m = new Float();
        int e = -127;
        int continu = 1;
        float fabs = m._abs(f);
        float p=1;

        while (continu==1 && e!=128) {
            e=e+1;
            if (p < fabs && fabs <= 2*p){
                continu = 0;
            }
            p=2*p;

        }

        return m._pow(2,e-23);
    }
}
