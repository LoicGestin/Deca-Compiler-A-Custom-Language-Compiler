// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

    float PI=4*MATH.atan(1);

    float pow(float f, int exp){
        if (exp==1){
            return 1;
        }
        return pow(f, exp-1);
    }

    protected float sinHornerFactor(float x2, int n, float inv_fact){

        inv_fact = inv_fact/(2*n*(2*n+1))

        if (n==255){
            return x2*inv_fact;
        }

        return inv_fact-x2*sinHornerFactor(x0,n+1,fact);
    }

    float sin(float f) {

        float x2 = Math.pow(f,2);
        float inter_res;

        if (Float.isNaN(f) || Float.isInfinite){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        inter_res=1-x2*sinHornerFactor(x2,1,1)

        return f*inter_res;
    }

    float cosHornerFactor(float x2, int n, float_inv_fact){

        inv_fact = inv_fact/((2*n+1)*(2*n+2));

        if (n==255){
            return x2*inv_fact;
        }

        return inv_fact - x2*cosHornerFactor(x2,n+1,inv_fact);
    }

    float cos(float f) {

        float x2 = Math.pow(f,2);

        if (Float.isNaN(f) || Float.abs(f)>1){
            return Float.NaN;
        }

        return cosHornerFactor(x2,0,1);
    }

    float asinHornerFactor(float x2, int n, float sqrt_num, float denom){

        sqrt_num = sqrt_num*(sqrt_num+1);
        denom = denom*2*n*(2*n+1);

        if (n==255){
            return Math.pow(sqrt_num,2)*x2/denom;
        }

        return Math.pow(sqrt_num,2)/denom + x2*asinHornerFactor(x2,n+1,sqrt_num,denom);
    }

    float asin(float f) {
        float x2 = Math.pow(f,2);
        float inter_res;

        if (Float.isNaN(f) || Float.abs(f)>1){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        inter_res = asinHornerFactor(x2,1,1,1)
        return f*;
    }


    float atantHornerFactor(float x2, int n){

        if (n==255){
            return x2/(2*n+1);
        }

        return atanHornerFactor(x2, n+1);
    }

    float atan(float f) {

        float x2 = Math.pow(f,2);

        if (Float.isNaN(f)){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        return f*atanHornerFactor(x2,0):
    }

    //Restranscription du code source de la classe Math de Java
    //https://developer.classpath.org/doc/java/lang/Math-source.html, l.1014-1051
    float ulp(float f){
         if (Float.isNaN(f))
           return f;
         if (Float.isInfinite(f))
           return Float.POSITIVE_INFINITY;
         // This handles both +0.0 and -0.0.
         if (f == 0.0)
           return Float.MIN_VALUE;
         int bits = Float.floatToIntBits(f);
         final int mantissaBits = 23;
         final int exponentBits = 8;
         final int mantMask = (1 << mantissaBits) - 1;
         int mantissa = bits & mantMask;
         final int expMask = (1 << exponentBits) - 1;
         int exponent = (bits >>> mantissaBits) & expMask;

        // Denormal number, so the answer is easy.
        if (exponent == 0)
           {
            int result = (exponent << mantissaBits) | 1;
             return Float.intBitsToFloat(result);
           }

         // Conceptually we want to have '1' as the mantissa.  Then we would
         // shift the mantissa over to make a normal number.  If this underflows
         // the exponent, we will make a denormal result.
         int newExponent = exponent - mantissaBits;
         int newMantissa;
         if (newExponent > 0)
           newMantissa = 0;
         else
           {
             newMantissa = 1 << -(newExponent - 1);
             newExponent = 0;
           }
         return Float.intBitsToFloat((newExponent << mantissaBits) | newMantissa);
    }
}


// End of Deca Math library
