// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

    float PI=4*MATH.atan(1);

    float pow(float f, int exp){
        if (exp==1){
            return 1;
        }
        return pow(f, exp-1);
    }

    protected float sinHornerFactor(float x0, int n, float num, float denom){

        float an;

        num = -num;
        denom = denom*(n+1)*(n+2);
        an = an +(num/denom);

        if (n==256){
            return an;
        }

        else if (n==0){
            an=0;
        }

        return an+x0*sinHornerFactor(x0,n+1,num,denom);
    }

    float sin(float f) {

        int n=0;
        float num = f;
        float denom = 1;
        float x0 = Math.pow(f,2);

        if (Float.isNaN(f) || Float.isInfinite){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        return sinHornerFactor(f,0,num,denom);
    }

    float cos(float f) {
        if (Float.isNaN(f) || Float.abs(f)>1){
            return Float.NaN;
        }

        int n=0;
        float num = 1;
        float denom = 1;
        float res = 1;
        while (n<256){
            num = -num*Math.pow(f,2);
            denom = denom*(denom+1)*(denom+2);
            res = res + (num/denom);
            n=n+1;
        }

        return res;
    }

    float asin(float f) {
        if (Float.isNaN(f) || Float.abs(f)>1){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        int n=0;
        float num = f;
        float denom = 1;
        float res = f;
        while (n<256){

        }

        return res;
    }

    float atan(float f) {
        if (Float.isNaN(f)){
            return Float.NaN;
        }

        else if (f==0){
            return 0;
        }

        int n=0;
        float num = f;
        float denom = 1;
        float res = f;
        while (n<256){
            num = -num*Math.pow(f,2);
            denom = 2*n+1;
            res = res+(num/denom);
            n=n+1;
        }

        return res;
    }

    //Restranscription du code source de la classe Math de Java
    //https://developer.classpath.org/doc/java/lang/Math-source.html, l.1014-1051
    float ulp(float f){
         if (Float.isNaN(f))
           return f;
         if (Float.isInfinite(f))
           return Float.POSITIVE_INFINITY;
         // This handles both +0.0 and -0.0.
         if (f == 0.0)
           return Float.MIN_VALUE;
         int bits = Float.floatToIntBits(f);
         final int mantissaBits = 23;
         final int exponentBits = 8;
         final int mantMask = (1 << mantissaBits) - 1;
         int mantissa = bits & mantMask;
         final int expMask = (1 << exponentBits) - 1;
         int exponent = (bits >>> mantissaBits) & expMask;

        // Denormal number, so the answer is easy.
        if (exponent == 0)
           {
            int result = (exponent << mantissaBits) | 1;
             return Float.intBitsToFloat(result);
           }

         // Conceptually we want to have '1' as the mantissa.  Then we would
         // shift the mantissa over to make a normal number.  If this underflows
         // the exponent, we will make a denormal result.
         int newExponent = exponent - mantissaBits;
         int newMantissa;
         if (newExponent > 0)
           newMantissa = 0;
         else
           {
             newMantissa = 1 << -(newExponent - 1);
             newExponent = 0;
           }
         return Float.intBitsToFloat((newExponent << mantissaBits) | newMantissa);
    }
}


// End of Deca Math library
